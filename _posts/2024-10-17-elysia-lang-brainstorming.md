---
layout: post
title: Elysia 语言头脑风暴
author: Faerxi
category: programming-languages
tag: [编程语言, Elysia]
---

# Elysia 语言头脑风暴

设计语言是一件非常复杂的事情，想法可能有很多但没办法一边捋顺一边权衡，这对我来说要求过高了。因此本篇将作为笔者头脑发散的地方，其中的语言特性并不代表最终设计。更加有条理的 Elysia 语言设计细节记录在另一篇文章（此处需要一个链接）中。

## 实体

我有一个梦想，编程语言中的所有语义单元都能用同一个词描述。这就是 **实体（Entity）** 概念的由来。从传统的语言特性触发，实体包含了下面这些：

- **对象（Object）**：也就是数据。
- **函数（Function）**：数据结构的映射逻辑。
- **类型（Type）**：数据的结构特征。

实体都是可以


## 函数

### 函数即模板

如果将函数的类型用最“简单”的方式表示出来，一种方式是将其视为其返回值的 Promise。下面仅作展示，将类型 `T` 的 Promise 类型记作 `{ T }` 的形式。实际上从类型标注形式来讲，远古语言 C 和较新的 Go 都“暗含”了这个观点：

```c
// add 左侧就是函数返回值类型。当参数类型符合要求时，我们得到的就是标注的 int
int add(int x, int y) {
    return x + y;
}
// add(1, 1) 正如标注所示，拥有类型 int
```

另一边 Go 的标注位置正好相反，但核心观点不变：

```go
// add 和参数列表右侧就是函数返回值类型。当参数类型符合要求时，我们得到的就是标注的 int
func add(x, y int) int {
    return x + y
}
```

函数可以看作是一个表达式的模板，当所有缺位的绑定被引入后，我们自然能得到一个对象。倘若先不考虑绑定的名字，我们很容易写出一些普通函数的类型：

```haskell
add : { Int }
add = { x : Int; y: Int; x + y }
```

之所以写 `{ Int }` 而非 `Int`，是因为即使返回恒定值的函数，也需要“调用”这一步骤才能得到结果：

```haskell
answer : { Int }
answer = { 42 }     -- { 42 } 和 42 还是有本质区别的
```

这种思路对于异步函数来说甚至额外地合适，正如本节一开始所说：我们拿到的是一个返回值的 “promise”，只不过比起同步函数，异步函数在需要所有绑定到位后还需要一步执行完毕的条件。

```c#
async_anwer : { Int }
answer = { async return 42 }
```

#### 所以我类型推导呢？

比较尴尬的点在于笔者实际上很推崇 C++ 这样的返回类型推导，即一切以函数参数类型驱动的返回类型推导：

```cpp
// 返回类型可以不写出来，多数情况下可以依赖参数类型
auto add(auto x, auto y) {      // 相当于返回 decltype(x + y)
    return x + y;
}
```

C++ 能让返回类型自动推导也有它语言设计的因素在：抛开冗长的类型不谈，lambda 表达式的类型是没有办法不用 `decltype` 的情况下标注的，此时唯一解就是返回类型自动推导。某种程度上这也是因为 C++ 缺少语言上对“可调用类型”的抽象。

> 展开来讲的话，如果不拘泥于 C++ 的“存储类型”（也就是能出现在 `using` 声明右侧的名字）的话，C++ 可以通过 concept 与模板机制做可调用类型的标注：
> ```cpp
> std::predicate<int> auto gt(int x) {
>     return [x](int y) { return y > x; };
> }
> ```
> 这个方案的缺陷主要来自于 concept 只存在于一阶模板中（比如我们没法写出来 `std::predicate<std::integral>` 这样的东西）。其次就是缺少对返回类型的约束，这在参数类型是泛型的时候可能会比较困难（比较好的方法可能是在函数返回之前经过一次 `if constexpr` 的返回类型检查，不通过就 `static_assert(false)`。
> 
> 话虽如此，笔者依然觉得 concept 这样的静态约束是做可调用类型抽象性能最优的方式（不需要胖指针和虚函数表），代价是膨胀的二进制（参考 C++ 模板）。

对于用户来说，比起返回值的标注（通常由代码分析工具完成），如何能正确调用一个函数更加重要。截至目前我们显然没有解决这个问题。


#### 参考模板

既然笔者说函数就是模板，那当然应该参考一下模板中的模板，真正的模板，原教旨模板，也就是 C++ 中的 template。我们暂时不考虑 concept 这种模板中比较羸弱的新晋选手，单纯从函数模板和类模板汲取一些灵感。

首先无论是哪种模板，都可以通过显式指定模板参数的方式来实例化模板。

```cpp
template<typename T, typename U>
auto add(T x, U y) {
    return x + y;
}
extern template auto add<int, double>(int, double); // 没问题

template<typename T>
struct foo {};

extern template struct foo<int>;        // 没问题
```