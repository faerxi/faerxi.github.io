---
layout: post
title: Elysia 语言设计
author: Faerxi
category: programming-languages
tag: [编程语言, Elysia]
---



# Elysia 语言设计

## 核心

Elysia 语言是一门强类型的脚本语言，它拥有下面的特征：

- 语法的一致性：一个关键字或符号的含义不取决于它的上下文。
- 特性的正交性：不设计“语言内的 DSL”，所有特性都可以有机结合。
- 强大的反射和编译期：支持代码生成和反射，可以编写和运行期代码一致的编译期和预处理期代码。
- 灵活健壮的类型系统：所有代码运行在类型系统之上，可以协助编译器/解释器产生易读的错误信息。


## 内置数据类型

内置数据类型指的是可以通过*字面量*构建的数据类型，比如整数、布尔值等。一些系统编程语言会自带一些精确位数的整数和浮点数类型，和汇编码一一对应。比较好的如 Rust 提供了如 `i32`、`u64`、`f32` 等类型，一目了然；差一点的如 Java 用 `int` 表示 32 位整数，`long` 表示 64 位整数；最恶劣的是 C++，`long` 的长度“可能”是 32 或 64 位，甚至还有一个 `long long` 来表示 64 位整数。

Elysia 不是系统级编程语言，因此不需要原生支持固定位数的整数和浮点数类型（当然，通过标准库提供内置实现是可行的）。从常用程度来看，只需要两种内置类型：

- 数字：用于数学计算和存储。
- 字符串：用于通用数据存储。

所有其它类型都可以抽象成上面两种数据的复合。

### 数

从用户角度来说，数不应该有大小的限制，同时都应该是有符号的，C++ 等语言中的溢出检查和有无符号整数之间的运算处理相当令人头疼。不过一旦不设边界，这些（除了性能以外）就不再是问题了。

```cpp
// C++ 中的情况：
2147483647 + 1      // 嗯？
-1 < 1ull           // 嗯？？

// 理想中的情况：
1231238175912839128192389159181239123912381237  // 没问题
1e1012856719238                                 // 没问题……？
2 + 3i                                          // 复数还是交给库比较合适
```

### 字符串

有关字符串，首当其冲就是对 Unicode 的支持。C++ 在这个方面是臭名昭著地迟钝。内置字符串理应默认支持 UTF-8。

```cpp
"四个字符"
```

随后是字符串插值。这实际上反映了“一切皆可序列化”的规律。不过这可能会给编译器前端造成一些困难：如果允许插值表达式包含任何内容，就没理由不支持其再包含一个（可供插值的）字符串。

```python
f"1:{f"2:{f"3:"}"}"
```

考虑到代码的可读性，也可以考虑禁止这样的用法。

值得一提的是，插值通常和字符串格式化一同出现（参考 Python 的 fstring 和 C 的 `printf`，虽然后者不是内置的支持）。这作为语言内置功能未尝不可，但是考虑到拓展性，将其放到标准库中似乎更合适（这和字符串插值不同，格式化很难找到一个通用的接口，插值仅需实体到字符串的转换函数即可，类型转换是编程语言中很常见的特性）。

### 其它类型？

#### 布尔类型

比如 C++ 等语言中的布尔类型（`true` 和 `false`），实话说没有内置的必要。它们再次也可以通过枚举类型来实现：

```cpp
enum Bool {
    True
    False
}
```

难以弥补的差别主要在于枚举值的名字不是关键字。将它们设置为默认导入的名字或许可以解决这个问题，或者学习 C 标准，设置一些“保留字”，如以下划线开头接大写字母的均不能作为自定义标识符，这样 `_True` 和 `_False` 总能为人所用。




## 模式匹配

**模式匹配（Pattern Matching）** 是基于数据的结构，以声明的形式匹配其子数据的机制。编程语言中有下面这几种典型的数据类型：

- 原始：单个数据。
- 元组：多个数据的聚合体。典型如 C 的 `struct`。
- 选择：可以容纳多种类型数据的联合体。典型如 C 的 `union`。
- 树：带有标签（构造器）的数据结构。典型如 Haskell 的 `data`。
- 表：通过哈希值快速访问的键值列表。

除此之外可能还有谓词、断言等手段辅助模式匹配，不过它们和对象的结构无关，我先放在一边。

### 原始

原始匹配看起来非常简单，因为它就是将对象完全匹配出来，但在语义上需要将一种特殊情况单列出来，那就是值匹配：

```python
x = 123
match value:
    case (x, y):
        return x + y
    case 42:
        return 0
    case x:
        return x
```

第一种和第二种匹配条件没有任何理解上的歧义，但第三种匹配就值得讨论了：我们究竟是在匹配一个原始结构，还是匹配 `x` 对应的值呢？

编译器看到 `case 42` 时，可以不假思索地将其识别为值匹配，这是因为字面量无法作为变量的名字。类似地，`case x.y` 也是一个值，因为 `x.y` 是两个名字的“运算结果”。唯一的特例就是 `case x` 这种情况：根据语言设计，它可能有三种含义：

- 原始匹配：将对象直接匹配为 `x`。
- 匹配名字：匹配 `x`（作为值本身），如果感觉迷惑的话可以对比 `case 42` 中匹配 `42` 这个值。
- 匹配值：匹配 `x` 引用的对象值。

在大多数语言中，“名字”不是一等公民，它们通常承担着标识符的重任。接纳名字到类型系统中有一些好处：

- 自此编程语言中，所有的词法单元对应的实体都是一等公民了：无论是 `foo`、`++` 还是 `42`，它们都拥有相同的待遇。增强语言一致性。
- 让静态反射、编译期代码生成变得更加轻松。

坏处也是显然的：

- 如果名字是对象，那就需要区分其引用功能（名字绑定）和本身作为值的功能。可能需要设计一套名字“退化”机制（参考 C++ 的函数与数组）。
- 运行期的名字可能和其使用特征格格不入，因此需要仔细考量这方面的设计。也可以让名字只能作为编译期的对象，但这样又会让它变得特殊（虽然退化机制让它已经不同寻常了）。



### 元组

关于**元组（Tuple）**，一个有趣但不离题的讨论是：一元组（乃至空元组）是否是元组？在写下 `(1, 0)` 时，我们看到了分隔符 `,`，因此能清晰地认识到这是一个（二）元组。但 `(1)` 是不是一元组呢？

我想大多数人不会承认它是一个元组，因为我们只看到了括号，而括号的功能是表达式组合。正如 `(1 + 1) * 2` 中的括号。Python 对此的解决方式是引入 trailing comma，即 `(1,)` 是元组，但 `(1)` 只是一个表达式。这实际上是相当聪明的做法，因为 trailing xxx 是编程语言中比较常见的设计，`(1, 2,)` 和 `(1, 2)` 没有区别。

需要确认的是，空元组有存在的必要性。一个“场外因素”是*包（Pack）*。包是建立在元组上的一个抽象，它代表一组数量不定的数据。我们可以让一个包展开，通常会得到一个元组。如果不承认一元组，可以让长度为 1 的包展开为一个对象，但长度为零的包展开是什么呢？

支持空元组其实没什么难的，它通常出现为 `()` 的形式，和所有其它的关键字字面量（如 `true`、`nullptr` 等）没什么区别。因此唯一的难点还是一元组。

说到底，`(1)` 的歧义来源于元组符号和表达式分组符号相同，而后者几乎是约定速成，在所有语言中都采用圆括号来表示，我自然不会在这里挑战传统。括号在许多语言中都被采用作为元组符号，如 Python、Haskell、C# 等，更特殊的一个参考是数学中的元组也通常用圆括号表示。不过，使用其它符号也不难接受，比如 Haskell 的列表使用 `[]`，而它从结构上类似于一个 Cons：

```haskell
data List a = Cons a (List a)
            | Empty

-- [1, 2, 3]
-- Cons 1 (Cons 2 (Cons 3 Empty))
-- 1:2:3:[]
```

这和元组的结构是等价的（事实上所有线性容器的语法表示都可以互换），因此方括号确实是一个合适的选择。


### 选择

Elysia 语言中的 **选择（Choice）**，在其它语言中通常称为 **和类型（Sum Type）** 或 **带标签的联合体（Tagged Union）**。它最大的问题是不存在特有的静态结构。

```cpp
union IntOrFloat {
    int i;
    float f;
};

IntOrFloat x = 42;              // 可变对象，无法静态判断实际结构
IntOrFloat const y = 3.14f;     // 不可变对象，但此时它只能是一个 float
```

因此选择并不适合通过结构匹配。

不过我们或许可以假定被匹配的对象属于某个选择类型，正如 Python 中的写法：

```python
match x:
    case 1 | 2 | 3:
        print("Small")
    case 4 | 5:
        print("Big")
    else:
        print("Bad")
```

但这种模式并不适用于多数情况，考虑一个 Rust 的 enum：

```rust
enum MyEnum {
    A(i32)
    B(f32, f32)
    C(String)
}

fn my_func(e: MyEnum) {
    match e {
        // 这里的 x 是什么？
        MyEnum::A(x) | MyEnum::B(x, y) => println!("{}", x)
        _ => println!("Nah")
    }
}
```

不过这并非完全不可行，只不过需要比较严谨的定义。后面我会找机会讨论一下它的应用方式。

### 树

树是由一个标签的父节点和数个表示数据的子节点构成的。可以参考 Haskell 中 ADT 的构造器和它对应的数据类型：

```haskell
data Tree a = Node a [Tree a]
            | Leaf
```

这里的 `Node a [Tree a]` 和 `Leaf` 都拥有树结构。树的好处在于，其结构可以通过标签匹配出来。

### 表

表即是词典结构，可以通过键（Key）高效地查询值（Value）。大多数语言中的表都是通过库来实现的，部分如 JavaScript 和 Python 中有内置的表结构：

```javascript
let t = { x: 42, y: "abc" }
console.log(t.x)
```

这两个语言中，表都是用大括号来表示的，这可以对应数学中的集合：表中键的唯一性正好和集合对应。在进行匹配时，我们可以参考其定义时的结构：

```javascript
let obj = { x: 42, y: "abc" }
let { x: xVal, y: yVal } = obj
console.log(xVal)               // 42
```

它相比元组指向性更强，通过名字匹配不容易出错。

### 符号选择

前面已经提到了和括号有关的设计困境，这里不妨详细讨论一下：

1. 括号（圆括号）：
    - 广泛用于表达式分组，这个功能几乎无可撼动。当然，数学中方括号也常用于相同场景。
    - 函数调用（类 C 语言），如 `f(1, 2)`，包括函数类型如 `void (int)`。这个用法可以通过引入元组类型来与前一个场景合并。
    - （特殊用法）类型转换（类 C 语言）：如 `(float)42` 等价于 `static_cast<float>(42)`。这个用法有很多替代品。
    - （特殊用法）运算符组（Haskell）：如 `(> 0)` 等价于 `\x -> x > 0`。
2. 方括号：
    - 下标运算（类 C 语言）：如 `a[0]`，包括数组类型如 `int[3]`。这种用法也拓展到不定长数组类型的表示，如 `int[]`。此外，下标也引申有“查询”的含义，如 C++ 各种库中对 `operator []` 的重载。
    - 切片（Python）：如 `a[1:10:3]` 表示从序号 `1` 到 `10`，每三个元素取一个。这个实用性上无可指摘，不过需要找到一个不那么“专用”的场景。
    - 泛型（Go）：如内置的 `map[string] int`。泛型机制很重要，但是独自占用一个特定的符号来表示有待商榷。
3. 大括号（花括号）：
    - 结构声明（类 C 语言）：如 `{ 1, 2, 3 }`（C++ 中的 brace-initializer）、`{ x: 42, y: "abc" }`（JavaScript 中的对象字面量，或 Python 中的词典）。一言以蔽之这是对数据结构的初始化声明。
    - 作用域声明（类 C 语言）：如 `namespace std { }`（C++ 的名字空间），`public class Foo {}`(Java、C# 的类)、`void foo() {}`（类 C 语言的函数）。作用域的用法在类 C 语言中的地位也算是难以撼动，不过替代方案也有很多，如 Python 和 Haskell 的缩进方案，或 Pascal、Ruby 的 `begin`、`end` 方案。
4. 尖括号：
    - 泛型（类 C 语言）：如 `ArrayList<Integer>`（Java）。泛型采用尖括号有其合理性（不与其它几个括号冲突），但容易造成词法分析的困难，比如 C++11 前的惯用法 `std::vector<std::vector<int> >`（注意 `> >` 而非 `>>`）。

程序语言中为了简便性，常常为内置结构类型让出一些符号，比如：

- Python 用 `()` 表示元组、`{}` 表示词典。
- Haskell 用 `()` 表示元组、`[]` 表示列表。

从结构性质来看，元组和列表并无相异之处：

- 它们都是线性顺序容器。
- 列表虽然是同质容器，但只要它的大小是确定的，就完全兼容元组的类型表示。比如 C++ 中的 `int[3]` 和 `struct { int x, y, z; }` 并无本质区别。

因此 Elysia 中的列表会和元组合并。

方括号因其惯用非常适于作为检索功能，检索时常用的操作有：

- 结构匹配：也就是本章前面所讲的，模式匹配中的一种形式。
- 切片：包含位置起始、结尾和步长。不过切片不一定需要特殊的语法。


### 模式嵌套

显然模式匹配应该支持嵌套声明（可惜的是很多语言并不支持，很多时候只能匹配一次之后再匹配；至于 C++17 引入的那个“结构化绑定”，我甚至不愿意称其为模式匹配），但此时不得不提及 aliasing 的问题。Haskell 中支持将嵌套的模式整体匹配出来：

```haskell
f :: [Int] -> Int
f [] = 0
f l@(x:xs) = x + f xs   -- l 匹配了整个列表，x:xs 是常规的列表匹配
```

现在的问题是，`l` 和 `x` 与 `xs` 是什么关系？对于 Haskell 这样的语言，它们不需要有任何关系，因为所有对象不可变，且没有取地址这样的神奇操作。但有值与引用之分的语言中，我们不得不正视匹配的方式：

```c++
extern std::pair<int, int> p;
auto [x, y] = p;        // 以值匹配
auto& [x, y] = p;       // 以引用匹配，因此 x, y 是 p 中两个子对象的而引用
// 并不意外地，C++ 没有提供部分用值，部分用引用的绑定方式
```

个人的观点是，默认情况下都应该通过引用匹配，因为从引用获得拷贝很容易，但反过来是不可能的（拷贝的引用不是原来的引用）。



## 函数

### 求值 vs 指令

无论在哪个编程语言中，**函数（Function）** 都是程序的一个“子结构”，比如 C 中的程序可以抽象为 `main` 函数，而所有其它函数都经由 `main`，或其调用的函数调用。

```cpp
int main(void)
{
    extern void foo(), bar();
    foo()
    bar()
}
```

函数式编程语言也类似，Haskell 中的 `main` 是一个 `IO ()` 值，所有其它函数同样也是一个求值的结构。

```haskell
main :: IO ()
main = do
  putStrLn "What is your name?"
  name <- getLine
  putStrLn ("Hello, " ++ name ++ "!")
```

因此有两种解释方式：

- 函数是在执行指令，只不过附带了一个执行结果（可以用于求值），有时候没有执行结果（比如 C 系语言中的 `void` 返回类型）
- 函数是在求值，只不过可能带有副作用（也就是指令的效果）

笔者更倾向于后面这种解释，下面会详细说明。